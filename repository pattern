Great ‚Äî here is the cleanest and easiest approach using System.Text.Json without wrappers, without creating two models, and without Newtonsoft.
This approach uses a runtime-controlled ignore list, so you can hide any property on any model based on the user role.

‚∏ª

‚úÖ BEST SOLUTION ‚Äî Runtime Property Hiding (Single Converter for All Models)

‚úî Only one converter needed
‚úî Works for any property, not just CompanyId
‚úî No duplicate DTOs
‚úî No nulls ‚Äî property is completely removed
‚úî Cleanest and most maintainable design

‚∏ª

‚≠ê Step 1 ‚Äî Create a static ‚ÄúIgnore List‚Äù for properties

Create a class to store which properties should be removed at runtime:

public static class JsonIgnoreContext
{
    public static HashSet<string> PropertiesToIgnore { get; } = new();
}


‚∏ª

‚≠ê Step 2 ‚Äî Create a custom converter for objects

Create a file: SelectivePropertyIgnoreConverter.cs

using System.Text.Json;
using System.Text.Json.Serialization;

public class SelectivePropertyIgnoreConverter<T> : JsonConverter<T> where T : class
{
    public override T Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        // Normal deserialization
        return JsonSerializer.Deserialize<T>(ref reader, options)!;
    }

    public override void Write(Utf8JsonWriter writer, T value, JsonSerializerOptions options)
    {
        writer.WriteStartObject();

        foreach (var prop in typeof(T).GetProperties())
        {
            string propName = prop.Name;

            // Skip if this property is marked to be ignored
            if (JsonIgnoreContext.PropertiesToIgnore.Contains(propName))
                continue;

            var propValue = prop.GetValue(value);
            var jsonName = options.PropertyNamingPolicy?.ConvertName(propName) ?? propName;

            writer.WritePropertyName(jsonName);
            JsonSerializer.Serialize(writer, propValue, propValue?.GetType() ?? typeof(object), options);
        }

        writer.WriteEndObject();
    }
}


‚∏ª

‚≠ê Step 3 ‚Äî Register the converter globally for your model

In Program.cs:

builder.Services.AddControllers()
    .AddJsonOptions(options =>
    {
        options.JsonSerializerOptions.Converters.Add(new SelectivePropertyIgnoreConverter<DocumentModel>());
    });


‚∏ª

‚≠ê Step 4 ‚Äî Your original model stays unchanged

public class DocumentModel
{
    public int? DocumentId { get; set; }
    public string? UserName { get; set; }
    public string? DocName { get; set; }
    public string? DocTypeID { get; set; }
    public int? Version { get; set; }
    public DateTime? DateEntered { get; set; }
    public string? DocTypeName { get; set; }
    public string? CompanyId { get; set; }
}

‚úî Nothing to modify
‚úî No wrapper properties
‚úî This is the cleanest model

‚∏ª

‚≠ê Step 5 ‚Äî Service decides which properties to ignore

public async Task<DocumentModel> GetDocumentAsync(string role)
{
    var model = await _repo.GetDocument();

    // Clear ignore list before every use
    JsonIgnoreContext.PropertiesToIgnore.Clear();

    if (role == "FACOMP")
    {
        JsonIgnoreContext.PropertiesToIgnore.Add(nameof(DocumentModel.CompanyId));
    }

    return model;
}


‚∏ª

‚≠ê Output Behavior

‚úî For FACOMP user ‚Üí CompanyId is removed

{
  "documentId": 1,
  "userName": "John",
  "docName": "Invoice.pdf",
  "docTypeID": "INV",
  "version": 1,
  "dateEntered": "2025-01-01T00:00:00Z",
  "docTypeName": "Invoice"
}

‚úî For Normal user ‚Üí all fields including CompanyId appear

{
  "documentId": 1,
  "userName": "John",
  "docName": "Invoice.pdf",
  "docTypeID": "INV",
  "version": 1,
  "dateEntered": "2025-01-01T00:00:00Z",
  "docTypeName": "Invoice",
  "companyId": "A001"
}


‚∏ª

üéØ Why this is the BEST approach
	‚Ä¢	No model pollution
	‚Ä¢	No custom types or wrappers
	‚Ä¢	No null hacks
	‚Ä¢	No duplicate DTOs
	‚Ä¢	No Newtonsoft dependency
	‚Ä¢	Centralized logic for hiding fields
	‚Ä¢	Works for ANY property of ANY model
	‚Ä¢	100% clean controller

‚∏ª

	If you want, I can also give you a version
 that supports lists of models automatically



 (DocumentModel inside a List or array).




Here is the generic version that can remove any property from any model for any role, without creating extra DTO classes manually.

This solution is:

‚úî Generic
‚úî Works for IEnumerable, List, or a single object
‚úî Removes the property completely from JSON (not null)
‚úî Uses reflection + ExpandoObject
‚úî Very reusable and clean

‚∏ª

‚úÖ 1. Generic Helper: Remove Selected Properties From Any Model

Create a helper file, e.g. /Helpers/ObjectSanitizer.cs

using System.Dynamic;
using System.Reflection;

public static class ObjectSanitizer
{
    /// <summary>
    /// Removes specified properties from each object in a collection.
    /// Returns a list of ExpandoObjects ready for JSON serialization.
    /// </summary>
    public static IEnumerable<object> RemoveProperties<T>(
        IEnumerable<T> source,
        params string[] propertiesToRemove)
    {
        var removeSet = new HashSet<string>(
            propertiesToRemove,
            StringComparer.OrdinalIgnoreCase);

        foreach (var item in source)
        {
            yield return RemoveProperties(item, removeSet);
        }
    }

    /// <summary>
    /// Removes specified properties from a single object.
    /// </summary>
    public static object RemoveProperties<T>(
        T source,
        HashSet<string> propertiesToRemove)
    {
        IDictionary<string, object?> expando = new ExpandoObject();

        var props = typeof(T).GetProperties(BindingFlags.Public | BindingFlags.Instance);

        foreach (var prop in props)
        {
            if (!propertiesToRemove.Contains(prop.Name))
            {
                expando[prop.Name] = prop.GetValue(source);
            }
        }

        return expando;
    }
}


‚∏ª

‚úÖ 2. Use It in Your Controller (for IEnumerable)

[HttpGet]
public async Task<IActionResult> GetDocuments()
{
    var role = User.FindFirst("role")?.Value ?? "";

    IEnumerable<DocumentModel> docs = await _service.GetDocumentsAsync();

    if (role == "FACOMP")
    {
        // remove CompanyId from every object in the list
        var sanitized = ObjectSanitizer.RemoveProperties(docs, "CompanyId");
        return Ok(sanitized);
    }

    // return full model for all other roles
    return Ok(docs);
}


‚∏ª

üéØ Result

For FACOMP (CompanyId removed completely)

[
  {
    "documentId": 12,
    "userName": "John",
    "docName": "Report1",
    "docTypeID": "PDF",
    "version": 2,
    "dateEntered": "2025-11-01",
    "docTypeName": "Annual Report"
  }
]

For other roles (CompanyId included)

[
  {
    "documentId": 12,
    "userName": "John",
    "docName": "Report1",
    "docTypeID": "PDF",
    "version": 2,
    "dateEntered": "2025-11-01",
    "docTypeName": "Annual Report",
    "companyId": "C789"
  }
]


‚∏ª

‚≠ê Why this generic solution is powerful
	‚Ä¢	Remove any property dynamically
	‚Ä¢	No DTOs needed
	‚Ä¢	Works for any model
	‚Ä¢	Works for IEnumerable, arrays, or single objects
	‚Ä¢	Very clean and maintainable
	‚Ä¢	Zero impact on your model classes
	‚Ä¢	Output stays perfectly formatted JSON

‚∏ª

üí¨ Want the version that removes multiple properties based on role rules?

Example:

if (role == "FACOMP")
    remove CompanyId;

if (role == "TEMP")
    remove DocTypeID, Version;

if (role == "CLIENT")
    remove UserName, CompanyId;

I can provide a full reusable policy system if you want.

